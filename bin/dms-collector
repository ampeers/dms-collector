#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
# dms-collector - a tool to retrieve dms table values from dms spy application on 
# defined intervals and convert them to csv format.
# 
# 08-2018, Tomas Vitvar, tomas@vitvar.com

# todo: 
# - check for http error, do not exit but try the next iteration
# - allow to run on a specific time in a minute --delay -X where X is number of minutes
#    + additional parameter to define in which second of the minute it should run
#   if the delay is greater than 1, then it should always run in minute of the hour, 
#   e.g. -2 will run in 00, 02, 04 and not in 01 03 05... 
# - add verbose flag
# - allow to join two or more tables on specific column name

import argparse
import re
import requests
import sys
import time
import datetime
import xml.etree.ElementTree as ET

from time import sleep

# version info
VERSION="1.0"
TBML_VERSIONS=["11.0"]

# input arguments
args=None
username=None
password=None

# normalize header names
def normalize(header):
    if args.origheader == False:
        return header.replace(".","_")
    else:
        return header

# check reg exp pattern and writes error message and exits when it does not match
def checkPattern(str, pattern, errormsg):
    p = re.compile(pattern)
    if not p.match(str):
        raise Exception(errormsg)

# retrieves data using HTTP get
def retrieveData(url):
    if username is None:
        r = requests.get(url)
    else:
        r = requests.get(url, auth=(username, password))        
    r.raise_for_status()
    root = ET.fromstring(r.text)   
    if not(args.noversioncheck): 
        tbml_version = root.get("version")
        if tbml_version not in TBML_VERSIONS:
            raise Exception("Data retrieved are of not supported tbml version %s. Supported versions are: %s"
                %(tbml_version,','.join(TBML_VERSIONS)))
    return root

# evaluates if str is number (int or float)
def isNumber(str):
    p = re.compile(r'^[\+\-]?[0-9]*(\.[0-9]+)?$')
    return str != '' and p.match(str)    

# chck positive int type for argparser
def check_positive(value):
    ivalue = int(value)
    if ivalue <= 0:
         raise argparse.ArgumentTypeError("%s is an invalid positive int value" % value)
    return ivalue

# *** evaluates filter on the row's tags and fields values        
def evalFilter(filter, tags, fields):
    try:
        for k,v in tags.items():
            if v is not None:
                exec(k + "=\"" + v + "\"")
        for k,v in fields.items():
            if v is not None:
                exec(k + "=" + str(v))
        return eval(filter)
    except Exception as e:
        #sys.stderr.write("Error when evaluating the filter '%s': %s!\n" % (filter, e)) 
        return False      

# gets tags and fields from the row
def getTagsFields(row): 
    tags   = { k:str(v)   for k, v in row.items() if not(isNumber(v)) }
    fields = { k:float(v) for k, v in row.items() if isNumber(v) }                            
    return tags, fields
    
def strinquotes(val):
    if args.nostrinquotes or isNumber(val):
        return val
    else:
        return "\"%s\""%val
    
# *** MAIN
if __name__ == "__main__":    
    try:
        # arguments
        parser = argparse.ArgumentParser(description='Weblogic DMS Spy table metric collector', add_help=False)
        
        required = parser.add_argument_group('required arguments')
        required.add_argument('--count', required=True, help='number of runs the data will be retrieved from DMS',metavar='<num>',type=check_positive)
        required.add_argument('--delay', required=True, help='delay in seconds between runs',metavar='<seconds>',type=check_positive)
        required.add_argument('--url', required=True, help='Weblogic admin server url where DMS Spy app us running',metavar='<url>')
        required.add_argument('--connect', required=False, help='username/password to login to DMS Spy',metavar='<u/p>')
        required.add_argument('--table', required=True, help='name of a valid DMS table which data to be retrieved',metavar='<tablename>')    
        
        optional = parser.add_argument_group('optional arguments')
        optional.add_argument("-h", "--help", action="help", help="show this help message and exit")
        optional.add_argument("-V", '--version', action='version', version='%(prog)s ' + VERSION + ', supports DMS tbml versions: ' + ','.join(TBML_VERSIONS))
        optional.add_argument('--filter', required=False, help='a condition that has to hold true for a row to be included in the output',default='',metavar='<python-expression>')    
        optional.add_argument("-ex",'--exclude', required=False, help='list of header fiedls to be excluded from the output',default='',metavar='<field1,field2,...>')    
        optional.add_argument("-in",'--include', required=False, help='list of header fiedls to be included in the output (all fields are included by default)',default='',metavar='<field1,field2,...>')    
        optional.add_argument('--noheader', required=False, help='suppress header in the output',default=False,action='store_true')    
        optional.add_argument('--origheader', required=False, help='use original header in the output, no normalization',default=False,action='store_true')    
        optional.add_argument('--timeformat', required=False, help='Python time format for datetime field (default is \'%%y-%%m-%%d %%H:%%M:%%S\')',default="%y-%m-%d %H:%M:%S",metavar='<format>')            
        optional.add_argument('--datetimefield', required=False, help='datetime header field name (default is \'datetime\')',default="datetime",metavar='<name>')            
        optional.add_argument('--timezonefield', required=False, help='time zone header field name (default is \'timezone\')',default="timezone",metavar='<name>')            
        optional.add_argument('--nostrinquotes', required=False, help='do not place string values in quotes',default=False,action='store_true')            
        optional.add_argument('--nodelayadjust', required=False, help='disables delay time adjustment',default=False,action='store_true')    
        optional.add_argument('--fieldstags', required=False, help='print only header\'s fields and tags and exit',default=False,action='store_true')            
        optional.add_argument('--printheader', required=False, help='print the table header and exit',default=False,action='store_true')    
        optional.add_argument('--noversioncheck', required=False, help='do not check tbml version',default=False,action='store_true')    
        
        args=parser.parse_args()
        
        # args checks
        checkPattern(args.url, r"^(http:)//([A-Za-z0-9\-\.]+)(:[0-9]+)?$", 
            "The admin url address '%s' is invalid! It should be in a form http(s)://hostname[:port]\n"%args.url)

        # connection information
        if args.connect is not None:
            connect = args.connect.split("/",1)
            username = connect[0]
            if len(connect) > 1:
                password = connect[1]
        exclude = [x.strip() for x in args.exclude.split(',') if x != '' ]
        include = [x.strip() for x in args.include.split(',') if x != '' ]
        
        # check filter expression
        # filter regexp example: bool(re.match(r\"WLS_SOA[0-9]+\",str(ServerName)))
        if args.filter != '':
            try:
                eval(args.filter)
            except Exception as e:
                if re.match(r".*invalid syntax.*", str(e)):
                    raise Exception("The filter '%s' is not a valid python expression (%s)!\n\n"%(args.filter,str(e)))
        
        # diable header when printing fields and tags only
        if args.fieldstags:
            args.noheader = True
            
        # remove trailing space from datatime and timezone fields from command line
        args.datetimefield = args.datetimefield.strip()
        args.timezonefield = args.timezonefield.strip()
        
        # get dms table description
        root = retrieveData(args.url + "/dms/Spy?format=xml&table=" + args.table + 
            "&description=true&value=false")                
        cdef = root.findall(".//columndef")
        
        fields = [normalize(x.get("name")) for x in cdef]
        fields.insert(0,args.datetimefield)
        fields.insert(1,args.timezonefield)        
        
        header = ','.join(x for x in fields if (x not in exclude and len(include) == 0) or x in include)

        # print header
        if not(args.noheader) or args.printheader:
            print header

        if args.printheader:
            sys.exit(0)
        
        count = 0
        while (count < args.count):
            # number of runs
            count = count + 1
        
            # current time
            stime = time.strftime(args.timeformat, time.localtime())
            tzone = time.strftime('%z')
            
            # current time in seconds for adustement of delay time
            time_s = time.time()
        
            # get dms table values
            root = retrieveData(args.url + "/dms/Spy?format=xml&table=" + args.table + "&value=true&cached=false")
            
            # iterate over all rows in the table
            for rw in root.findall(".//row"):
                row={}
                row[args.datetimefield] = stime
                row[args.timezonefield] = tzone
                
                for cd in cdef:
                    key=normalize(cd.get("name"))
                    cv = rw.find("./column[@name='%s']"%cd.get("name"))
                    if cv is not None and cv.text is not None:
                        if cv.text.strip() != '':
                            row[key] = cv.text.strip()
                        else:
                            row[key] = "n/a"   
                    else:
                        row[key] = "n/a"
                # end for cd
                
                # only print fields and tags on the first row and exit
                if args.fieldstags:
                    tags, fields = getTagsFields(row)
                    print "tags:", ','.join(k for k,v in tags.items() if k in header.split(','))
                    print "fields:", ','.join(k for k,v in fields.items() if k in header.split(','))
                    sys.exit(0)                            
                
                # evaluate the filter
                output_row = True
                
                # build tags and fields for this row for filter evaluation
                if args.filter != '':
                    tags, fields = getTagsFields(row)
                    output_row = evalFilter(args.filter,tags,fields)
                
                if output_row is True:
                    print ','.join(x for x in
                    [strinquotes(row.get(x)) for x in header.split(',')
                    if (x not in exclude and len(include) == 0) or x in include])
            # end for rw        
            
            # the time in seconds it took to retrieve the data
            # disable it when explicitly disabled
            if args.nodelayadjust:
                elapsed_s = 0
            else:
                elapsed_s = time.time() - time_s
            
            # check if time adjustment makes sense
            if elapsed_s > args.delay*0.75:
                sys.stderr.write("[" + str(datetime.datetime.now()) + "]: It took %d seconds to retrieve the DMS table '%s' which is more than 2/3 of the delay (%d seconds). The time will not be adjusted which in turn will cause the dms collector to run more than %d seconds!\n"
                    %(elapsed_s,args.table,args.delay*0.75,args.count * args.delay))
                elapsed_s = 0
            
            # adjust the delay time and sleep
            sleep(args.delay - elapsed_s)
            
        ## end loop
        
    except (KeyboardInterrupt, SystemExit):
        pass
    except Exception as e:
        sys.stderr.write("Error: %s\n"%str(e))

# end main    
